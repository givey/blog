---
layout: post
title: Content Sharing System
date: '2015-12-16T07:46:30+00:00'
tags:
- backend
- frontend
- development
- api
- code
tumblr_url: http://blog.givey.com/post/135314419950/content-sharing-system
---
<p><b>We have always been transparent at Givey when it comes to the business side of things. So we thought why not be transparent about our technology?</b><br/></p><p>There is a lot going on behind the scenes on Givey, but where better to start than our unique content system.</p><p>You will no doubt be aware that you can now choose images from your Facebook or Instagram account to serve as content for donations, so let&rsquo;s take a look at the process.</p><figure data-orig-width="854" data-orig-height="651" class="tmblr-full"><img src="http://40.media.tumblr.com/e925ce128bdccd6d767f5fcde5647b82/tumblr_inline_nzgbe2UFdp1rbfms4_540.png" alt="image" data-orig-width="854" data-orig-height="651"/></figure><p>Originally, we wanted to incorporate the Facebook login dialog. It is a much better experience for our users since it allows you to remain on Givey while logging in. However, we also had to consider how users would use Instagram. Instagram doesn’t have the same popup that Facebook provides so, in an effort to make things simpler for both ourselves and our users, we decided to use the redirect method.</p><p>So, when you click either the Facebook or Instagram button, you are taken to the respective website in order to confirm the request for permissions. Once you accept the permissions, you are redirected back to Givey with a code in the URL. We use this code to get an access token for you. The problem with this code parameter is that you cannot rename it. Instagram and Facebook both use the parameter name of “code”. So, in order to differentiate the code, we add the “provider” parameter.</p><p>Now that we have these parameters, we can get your photos. The problem we came across though is that you just land on the same page and have to click the button again. So, with a little help from Javascript, we auto click the relevant button. </p><p>This button triggers a method which loads the relevant module. We have several modules for each of the main providers we support. These modules all have the same methods (“authorize_api”, “channel_resources”, “single_resource”). Before we load your images, we need to obtain an access token for you. That’s where the code comes in. We send that to the module and trigger the “channel_resources” method. This method needs to call the “authorize_api” method in order to get the access token. So, we send the code to Facebook and they return an access token for us to use. With this access token, we create an identity for you in our database (or update it if it already exists).</p><p>For Facebook, we use the <a href="https://github.com/arsduo/koala" target="_blank">Koala gem</a> to send requests to the Facebook API. This makes it easy for us to get things like access tokens and retrieve information about you.</p><p>Instagram is a bit simpler. All we need to do is send a normal HTTP request to the instagram API with the access token. Once we retrieve your photos, we display them in a modal for you to choose from.</p><p>We knew we needed some sort of pagination, so we decided to go with the classic page 1, page 2 etc method. This worked well for Facebook. The API response provides a token which can be used to access the next page of results or the previous page of results. Instagram do things a bit differently however. Their site is built using an infinite scrolling pagination system. Their API also follows the same technique. They do provide a next page token in the form of the last ID of the last photo, but they have no way to get the previous page. We had to decide whether we were going to “monkey patch” a previous page link, or use the infinite scrolling option. We decided on the latter as it made much more sense than writing code just to make one provider work when they would all work with the infinite scroll option. </p><p>Once you have decided on which of your photos you would like to share, we send that request off to the server. This invokes the next module method “single_resource”. We again need to authenticate this request, but as you will recall, we stored the access token in our database. So we call the same “authorize_api” method. This method checks to see if there is a “code” parameter passed to it. If not, it uses the “user_id” parameter to grab the Identity we created/updated and use its token to get the resource.</p><p> After the API returns the information, we copy the photo and upload it to <a href="http://cloudinary.com/" target="_blank">Cloudinary</a>, which is our image storage provider. We need to copy the photo so that we can avoid issues with display properties and permissions on the photo. When you chose the photo, you gave us permission to view it but this isn’t the case for a normal user viewing your photo on Givey. They would need to have permission to see it.</p><p>And that’s how the image upload portion of the new content system works.</p><p>The URL box is a different matter. When you enter a URL we first need to parse it. We detect the host of the URL and check to see if we have a provider module for it. These modules are all specific to the provider and all contain their own methods of getting information about the content, while maintaining the class structure (“authorize_api”, “channel_resources”, “single_resource”).</p><p>If we don’t have a module for the URL (ie: you have chosen to share your blog) then we need to get the information ourselves. We do this by scraping the web page and grabbing its meta data. We use a gem called <a href="http://www.nokogiri.org/" target="_blank">Nokogiri</a> which allows us to make a request to the web page and parse the HTML elements.</p><p>This posed a problem since not all websites contain all the meta data we need and some contain other forms of meta data (Wordpress). So, in an attempt to get as much information as we can, we check for several different types of meta data.</p><p>The information we are looking for is the title, description and an image. We first attempt to look for Facebook meta data.</p>
<pre><code>&lt;meta name=”og:title” content=”” /&gt;
&lt;meta name=”og:description” content=”” /&gt;
&lt;meta name=”og:image” content=”” /&gt;
</code></pre>
<p>If we can’t grab any of that, we look for Wordpress meta data. </p>
<pre><code>&lt;meta property=”sailthru.title” content=””  /&gt;
&lt;meta property=”sailthru.description” content=””  /&gt;
&lt;meta property=”sailthru.image.full” content=””  /&gt;
</code></pre>
<p>We eventually default to the normal meta data.</p>
<pre><code>&lt;title&gt;&lt;/title&gt;
&lt;meta name=”description” content=”” /&gt;
</code></pre>
<p>If we do find an image, we need to verify it is a valid image. We do this by sending a request to the URL of the image and verify the HTTP status.</p><p>Regardless of the method chosen to upload content, everything else is the same after we have all the information we need. </p><p>By Carl Markham</p>
